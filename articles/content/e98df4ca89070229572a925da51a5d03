<div id="readability-page-1" class="page"><div><p>What if we were to model a typical software development lifecycle in code?</p>

<p>The unit of work would be the fundamental abstraction. We’d build state machines and workflows around it, carrying it from specification to deployment through activities performed by product managers, engineers, designers, and others. The process could be customised to each team’s needs, with all the bells and whistles. But fundamentally, its effectiveness and adaptability depends on how good this central abstraction is.</p>

<p>Get this abstraction wrong, and complexity scales exponentially. All the processes built around it inherit the dysfunction. Planning becomes chaotic, progress becomes opaque, and coordination becomes an expensive mess.</p>

<p>We deal with leaky abstractions by periodically refactoring them, so why not do the same thing with the unit of work? What makes a good unit of work? Let’s walk through these familiar activities and observe the properties that emerge.</p>

<h2 id="breaking-it-down">Breaking it down</h2>

<p>We typically start with product or feature requirements. We don’t usually take on a full feature in one shot, it’s “too big”. Especially if it’s complex enough to need some technical design and specification written along with it. We break it down into <strong>small</strong> parts that are more approachable for solving, and also give us a steady sense of progress.</p>

<p>Now the product requirement is actually a <em>hypothesis</em> for creating business value, and we need to validate the hypothesis as early as possible. So, the small parts need to be <strong>valuable</strong> to the customer.</p>

<p>In other words, we need the unit of work to be a slice of the cake, not a layer.</p>

<p><img src="https://blog.nilenso.com/images/blog/breaking-it-down.webp" alt="slice-of-cake"></p>

<p>Of course, bug fixes and refactors aren’t providing value in the same way, and that’s okay. Sometimes there are technical tasks that are best left independent. That’s okay too. No need to be dogmatic as long as the broad needs of value and sense of progress are being met.</p>

<h2 id="planning">Planning</h2>

<p>Before starting work, we want to <strong>prioritise</strong>, because it saves a lot of time. We want to ship the most valuable slices first, and perhaps discard some low priority slices. But we can’t prioritise without weighing the business value against the implementation effort. All slices aren’t the same size, so we <strong>estimate</strong> the implementation effort first.</p>

<p>Then, some large slices can have low product value, so we would want to break them into even smaller slices to prioritise parts we care about most. Some other large slices can’t be sliced further meaningfully, and that’s okay. Some smaller slices can’t be engineered independently, so we build the larger slice anyway. The unit needs to be <strong>negotiable</strong>.</p>

<p><img src="https://blog.nilenso.com/images/blog/planning-cake-cut.webp" alt="planning-with-slices"></p>

<p>And since we’re doing this as a team, we’ll want to ensure that the slices are as <strong>independent</strong> as possible, so that we can each do our part without waiting, and we don’t step on each other’s toes.</p>

<h2 id="gathering-context">Gathering context</h2>

<p>A unit can be specified today, picked up for execution next month, blocked by another task, and then deprioritised into the backlog. Over its life, it gathers context about various things:</p>

<ul>
  <li>What value it provides, how to verify it</li>
  <li>How it needs to be implemented</li>
  <li>Missing pieces of context that came together after conversations</li>
  <li>Unknowns that were resolved or unresolved</li>
  <li>Who worked on it, what issues they ran into</li>
  <li>What bugs came up in testing, and QA before release</li>
</ul>

<p><img src="https://blog.nilenso.com/images/blog/gathering-context.png" alt="gathering-context"></p>

<p>Keeping these pieces of <strong>context collected in a single place</strong> helps in picking it up from where it was left off. When discussing, implementing, or tracking, it’s useful to have the same artifact in front of us.</p>

<h2 id="solving">Solving</h2>

<p>Knowing exactly what we’re solving for is very helpful, so we can build <em>just enough software™️</em>. No more, no less. So we need to define the <strong>acceptance criteria</strong> that we can all agree on.</p>

<p>Then, solve until we meet them.</p>

<p>It’s good to <strong>automate</strong> checking whether they meet the acceptance criteria, because we’re going to be doing that an awful lot while solving.</p>

<h2 id="verifying">Verifying</h2>

<p>Confidence usually doesn’t require checking every possible case, only the key ones that capture most of the impact. Yes, we checked this slice at every step of the way, but it is useful to inspect it one last time before serving.</p>

<p>When is a unit considered <strong>done</strong>? When the slice has been served. When it’s in the hands of the user, in production, potentially behind a feature flag.</p>

<p><img src="https://blog.nilenso.com/images/blog/verifying.webp" alt="verifying"></p>

<p>And that’s it. To manage the life cycle of software development, we manage the unit of work. Some would say we need to <a href="https://xp123.com/invest-in-good-stories-and-smart-tasks/">INVEST</a> in good units of work. And some of you might rightly recognise that it looks like a <a href="https://c2.com/xp/UserStory.html">User Story</a>. But as long as the described properties and affordances for its users exist, it should make for a decent unit of work regardless of what we call it.</p>

<hr>

<h2 id="does-your-unit-of-work-need-refactoring">Does your unit of work need refactoring?</h2>

<p>We’re fairly aware of the penalties of leaky abstractions in software. The incidental complexity of getting our primary real world abstractions wrong, grows exponentially with each layer of software built over it, until the whole system is slow, sludgy slop that’s difficult to work with. We can hack it here and there, and celebrate minor wins, but the big wins were lost in the ignored opportunities to refactor that central abstraction.</p>

<p>If we apply the same thought process to software development, we’ll see that our core abstraction, the unit of work, might need refactoring.</p>

<p>Big gains in developer productivity in this economic weather are important. Organisations that use DORA measure deploy or commit frequencies might find them valuable in some dimensions, but they’re not a measure of productivity in terms of outcomes for the customer. I love these last lines in <a href="">Kent Beck’s writing about measuring developer productivity</a>:</p>

<blockquote>
  <div><p>Be suspicious of anyone claiming to measure developer productivity. Ask who is asking &amp; why. Ask them what unit they are measuring &amp; how those units are connected to profit.</p><p>

I am 100% pro-accountability. Weekly delivery of customer-appreciated value is the best accountability, the most aligned, the least distorting.</p></div>
</blockquote>

<p>And I think a unit of work as defined above could be used to measure productivity holistically. Prioritising by value, eliminating unnecessary work, and validating quickly then become obvious, and measurable ways to increase productivity.</p>

<p>Productivity gains through use of AI assistants is also popularly reported and benchmarked in terms of % of code generated, but that’s not a very valuable dimension for measurement. If the benchmarks for AI productivity revolved around units of work valuable to the customer, then we’d be talking true productivity gains. AI assistants also need small, well specified slices of work, and hence, will also benefit from a well defined unit of work. My colleague Atharva has written a wonderful <a href="https://blog.nilenso.com/blog/2025/09/15/ai-unit-of-work/">blog post</a> about that in detail.</p>

<p>Yeah, this article is mostly about rehashing a two-decade-old pitch for some common sense agile. But I hope it has been worth your time.</p>

<h2 id="annexes">Annexes</h2>

<ul>
  <li>In reality, the workflow isn’t as linear, and there is much back and forth between the steps. I’ve kept it simple to focus on the properties.</li>
  <li>Yes, I’m aware the classic definition of user stories doesn’t have implementation details.</li>
  <li>Slicing can happen across many dimensions, and breaking down a hard problem effectively, can actually be a very hard problem.</li>
  <li>
    <p>If you want to read the OG Agile material, you can read:</p>

    <ul>
      <li>Kent Beck introducing story cards in <a href="https://www.goodreads.com/book/show/67833.Extreme_Programming_Explained">XPX</a> (Chapter 15 on planning)</li>
      <li>Bill Wake’s <a href="https://xp123.com/user-stories/">writing</a>, and the INVEST criteria are condensed, quick reads</li>
      <li>The <a href="https://c2.com/xp/UserStory.html">C2 page</a> on User Stories for opinions and some discussions</li>
      <li>Ron Jefferies on <a href="https://ronjeffries.com/xprog/articles/expcardconversationconfirmation/">Card, Conversation and Confirmation</a>.</li>
      <li>Mike Cohn’s <a href="https://www.goodreads.com/book/show/3856.User_Stories_Applied">User Stories Applied</a> is a deep dive.</li>
    </ul>
  </li>
  <li>I like <a href="https://newsletter.pragmaticengineer.com/p/measuring-developer-productivity">Gergely Orosz&nbsp;and&nbsp;Kent Beck’s response to McKinsey</a> on measuring developer productivity. Gergely’s <a href="https://newsletter.pragmaticengineer.com/p/developer-productivity-a-new-framework">writing about DORA, and SPACE</a> is interesting, but I wonder if metrics can be more granular, around this unit of work, and its affordances. That would shift-left the feedback on productivity, to where it matters.</li>
</ul>
</div></div>
